<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>1_类的基本知识</title>
</head>
<body>
  <script type="text/javascript">
    // 1.创建类
    class Person {
      // 构造器方法
      constructor(name, age){
        // 此处this指的是  类的实例对象
        this.name = name
        this.age = age
      }

      // 一般方法
      speak(){
        // speak方法放在了哪里?   ---   类的原型对象上, 供类的实例对象使用
        // 通过Person实例调用的speak时,speak找中的this就是Person实例
        console.log(`我叫${this.name},我今年${this.age}岁了`)
      } 
      
    }

    // 继承
    class Student extends Person {
      constructor(name,age,grade){
        super(name,age)  //super是继承的关键字 如果是继承的类此处必须要调用
        this.grade = grade
        this.school = '尚硅谷'
      }
      /* 类中可以直接写赋值语句 */

      // 重写从父类继承过来的方法
      speak() {
        console.log(`我叫${this.name},我今年${this.age}岁了, 我今年读${this.grade}`)
      }
      study() {
        // study方法放在了哪里?   ---   类的原型对象上, 供类的实例对象使用
        // 通过Student实例调用的study时,study找中的this就是Student实例
        console.log('我很努力的学习')
      }
    }

    // 2.创建一个类的实例对象
    // const p1 = new Person('tom',12)
    // const p2 = new Person('jerry',13)

    // console.log(p1)
    // console.log(p2)
    // p1.speak()
    // p2.speak()

    const s1 = new Student('张三',11, '高一')
    console.log(s1)
    s1.speak()



    // 总结
    /* 
      1.类中的构造器不是必须要写的,当对实例需要进行一些初始化的操作,如添加指定的属性时才需要写
      2.如果A类继承了B类,且A类中写了构造器,那么A类构造器中的super是必须要调用的(子类的构造函数必须执行一次super函数。)
      3.类中所定义的方法,都是放在了类的原型对象上,供实例使用
     */


    class Car {
      constructor(name, price) {
        this.name = name
        this.price = price
        // this.wheel = 4
      }
      // 类中可以直接写赋值语句,如下代码的含义是:给Car的实例对象添加一个属性,名为a,值为1 (eg: a=1)
      wheel = 4//加在类的实例对象上
      static demo = 100 //加在了类的本身上
    }
    const c1 = new Car('奔驰',119)
    const c2 = new Car('宝马',189)
    console.log(c1)
    console.log(c2)
    console.log(Car.demo)
  </script>
</body>
</html>